---
description: Use if you're writing a new source connection.
globs: 
alwaysApply: false
---
# Airweave API Source Integration Coding Guide


### Real Examples

- **Slack**: Multi-resource API with channels, users, and messages @slack.py @slack.py
- **Stripe**: Complex pagination with many resource types @stripe.py @stripe.py
- **Asana**: Hierarchical data with file handling capabilities @asana.py @asana.py

When implementing a new API-based source, you'll need to:

## 1. Define Entity Schemas

For each data type from your API, create a corresponding entity schema in `app/platform/entities/your_service.py`:


It extends from @_base.py the BaseEntity, ChunkyEntity or FileEntity.


```python
class Breadcrumb(BaseModel):
    """Breadcrumb for tracking ancestry."""

    entity_id: str
    name: str
    type: str


class BaseEntity(BaseModel):
    """Base entity schema."""

    # Set in source connector
    entity_id: str = Field(
        ..., description="ID of the entity this entity represents in the source."
    )
    breadcrumbs: list[Breadcrumb] = Field(
        default_factory=list, description="List of breadcrumbs for this entity."
    )
    ...

class ChunkEntity(BaseEntity):
    """Base class for entities that are storable and embeddable chunks of data."""

class FileEntity(BaseEntity):
    """Base schema for file entities."""

    # Set in source connector
    file_id: str = Field(..., description="ID of the file in the source system")
    name: str = Field(..., description="Name of the file")
    mime_type: Optional[str] = Field(None, description="MIME type of the file")
    size: Optional[int] = Field(None, description="Size of the file in bytes")
    download_url: str = Field(..., description="URL to download the file")

```


**What you will need to implement, based on the API object described in docs:**

```python
class YourServiceEntity(ChunkEntity):
    """Schema for your service entity."""
    
    name: Optional[str] = None                  # Entity name
    some_count: int                             # Some count in entity
    created_at: datetime                        # created_at field
```

The `entity_id` usually is just the id of the item in the API. If not, find a primary key in the object.


## 2. Implement Source Connector

Create your source implementation in `app/platform/sources/your_service.py`:

```python
@source("Display Name", "your_service", AuthType.oauth2)
class YourServiceSource(BaseSource):
    """Your service source implementation."""
    
    BASE_URL = "https://api.yourservice.com/v1"
    
    @classmethod
    async def create(cls, access_token: str) -> "YourServiceSource":
        """Create a new source instance with authentication."""
        instance = cls()
        instance.access_token = access_token
        return instance
    @tenacity.retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=2, max=10))
    async def _get_with_auth(self, client: httpx.AsyncClient, url: str, params: Optional[dict] = None) -> dict:
        """Make authenticated API request."""
        headers = {"Authorization": f"Bearer {self.access_token}"}
        response = await client.get(url, headers=headers, params=params)
        response.raise_for_status()
        return response.json()
    
    async def _generate_resource_entities(self, client: httpx.AsyncClient) -> AsyncGenerator[ChunkEntity, None]:
        """Generate entities from a specific resource type."""
        url = f"{self.BASE_URL}/resources"
        
        # Handle pagination (if needed)
        next_cursor = None
        while True:
            params = {"limit": 100}
            if next_cursor:
                params["cursor"] = next_cursor
                
            response = await self._get_with_auth(client, url, params)
            
            for item in response.get("items", []):
                yield YourServiceEntity(
                    entity_id=item["id"],
                    name=item.get("name"),
                    created_at=datetime.fromisoformat(item.get("created", "")),
                    content=item.get("description", ""),
                )
            
            # Check if there are more pages
            next_cursor = response.get("next_cursor")
            if not next_cursor:
                break
    
    async def generate_entities(self) -> AsyncGenerator[ChunkEntity, None]:
        """Main entry point to generate all entities."""
        async with httpx.AsyncClient() as client:
            # Generate entities for each resource type
            async for entity in self._generate_resource_entities(client):
                yield entity
            
            # Add additional resource generators as needed
            # async for entity in self._generate_other_resource_entities(client):
            #     yield entity
```

## 3. Best Practices

- **Error Handling and Retries**: Use Tenacity for robust retry mechanisms
  ```python
  @retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=2, max=10))
  async def _get_with_auth(self, client: httpx.AsyncClient, url: str) -> Dict:
      """Make authenticated GET request to API."""
      response = await client.get(
          url,
          headers={"Authorization": f"Bearer {self.access_token}"},
      )
      response.raise_for_status()
      return response.json()
  ```

- **Modular Entity Generation**: Create separate methods for different entity types
  ```python
  async def generate_entities(self) -> AsyncGenerator[ChunkEntity, None]:
      """Main entry point to generate all entities."""
      async with httpx.AsyncClient() as client:
          # First generate parent entities
          async for workspace_entity in self._generate_workspace_entities(client):
              yield workspace_entity
              
              # Then generate child entities with breadcrumbs
              async for project_entity in self._generate_project_entities(
                  client, 
                  {"gid": workspace_entity.entity_id}, 
                  workspace_breadcrumb
              ):
                  yield project_entity
  ```

- **Breadcrumb Management**: Build breadcrumb hierarchies for nested resources
  ```python
  # Create breadcrumb for the parent entity
  workspace_breadcrumb = Breadcrumb(
      entity_id=workspace_entity.entity_id,
      name=workspace_entity.name,
      type="workspace",
  )
  
  # Pass parent breadcrumbs to child entities
  project_breadcrumbs = [workspace_breadcrumb, project_breadcrumb]
  ```

- **File Handling**: Use dedicated streaming methods with proper error handling
  ```python
  async def _stream_file(self, client: httpx.AsyncClient, url: str) -> AsyncGenerator[bytes, None]:
      """Stream a file with authentication."""
      retryer = AsyncRetrying(
          retry=retry_if_exception_type(httpx.HTTPError),
          wait=wait_exponential(multiplier=1, min=2, max=10),
          stop=stop_after_attempt(3),
      )
      
      async for attempt in retryer:
          with attempt:
              try:
                  async with client.stream("GET", url, headers=headers) as response:
                      response.raise_for_status()
                      async for chunk in response.aiter_bytes():
                          yield chunk
              except Exception as e:
                  logger.error(f"Error streaming file: {str(e)}")
                  raise
  ```

- **File Processing**: Use the file manager to process file entities
  ```python
  file_entity = YourServiceFileEntity(
      source_name="your_service",
      entity_id=file_data["id"],
      file_id=file_data["id"],
      name=file_data.get("name"),
      mime_type=file_data.get("mime_type"),
      size=file_data.get("size"),
      download_url=file_data.get("download_url"),
  )
  
  # Stream the file and process it
  file_stream = self._stream_file(client, file_entity.download_url)
  yield await handle_file_entity(file_entity, file_stream)
  ```
